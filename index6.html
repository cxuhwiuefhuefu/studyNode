<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script>
        
        // NodeLesson1




        // 第一部分
        // 后端的规范和思想
        // 第二部分
        // 基础API
        // 第三部分
        // 常见的框架
        // 第四部分 (Web项目)
        // 1.接受Web请求
        // 2.处理业务逻辑
        // 3.文件操作
        // 4.数据库(关系型数据库MySQL 非关系型数据库MongoDB)
        // 5. 我们浏览器发出一个请求 不是直接访问的服务器 为啥不是直接的访问的服务器 例如百度 一台服务器撑不起百度流量的 百度一秒钟可能有好几百万的人在使用
        //        你一台服务器再好的性能也扛不住 所以百度在每个地方都会有一个大的机房 这个机房可能有成百上千台机器 那你这个请求到底会打在那台机器上
        //        是你浏览器说的算的吗 肯定不是 肯定是你的浏览器访问DNS DNS给你一个百度的机房的路口 如何这个机房入口去分配 这个机房入口就是反向代理服务器
        //        就是我们实际请求是打在反向代理服务器上 这个反向代理服务器实际上就是一个宾馆的前台 它来给你分配 反向服务器去选择后面一台服务器 
        //        把我们请求转发给他 这个选择有Ip哈希(192.168... 我有10台机器 最后一个尾数除以10取余),轮询(第一台请求给第二台 第二个请求给第二台...第十一个请求再给第一台)
        // 借一个具体的项目我来实现这样的功能
        // 第五部分
        // 大项目(Vue NodeJs 模拟项目)



        // 一丶后端的规范与思想(后端功能的复杂度高于前端 复杂的业务逻辑在后端来做 前端主要复杂展示 虽然前端页面做一些逻辑 主要做展示和用户进行交互的 后端主要负责业务逻辑的 京东有电商的逻辑 博客有逻辑 
        //      繁杂逻辑难以处理 所以后端需要划分层次 让每个层次都比较清晰 这样我们可以把一个复杂的业务分成几个清晰的层次 前端：负责展示的html和css
        //      负责逻辑的就是js 负责网络的就是ajax之类的)
        // 1. 分层
        //    (1) Web层(接收和发送Http请求的, 封装(传过来的值我得给它转换为对象), 有人叫它为web层 有人叫它为controller层(java c#) )
        //    (2) 业务逻辑层 (公司一般称为服务层, 这一层的文件通常以XXXService结尾的 是一个什么服务 服务是一个什么概念 服务就是一个概念 比如注册功能 
        //        最外层负责登录的LoginController(接收参数, 判断是否非法, 传给服务层) 比如你提交了一个用户名和命名 我把他获取一下 
        //        如何判一下是否合法 如何发给服务层 服务层一般叫LoginService(获取一下这个用户的密码, 进行比较) 一般我们把用户的密码存在数据库里 
        //        怎么取 就用到下面这一层了 )
        //    (3) DAO层(以下四件事情往往是DAO层来做  数据和对象的相互转化以及对数据库的读取)
        //        1. DataBase(DB): 数据库存的是数据  
        //        2. 业务:不是用数据直接参与运算 往往对一个对象直接进行操作
        //        比如一个学生 我想把学生存在数据库里 是不是我得把学生这个对象转换为数据 如果要存储就要把对象转化为数据 如果要读取 
        //            就是要从数据库里拿的时候 我得把数据转换为对象
        //        3. 如果要存储: 对象 转为 数据
        //        4. 如果要读取: 数据 转为 对象
        //    (4) 持久层 (为什么叫持久层 我们希望这个数据持久的保存 )
        //        我们正常的数据都存在一个变量里 但函数随着你函数变量生命周期是不是没了 除非你存在全局的变量里 就算你存在全局变量里 
        //            你这个服务器机器一旦重启 也就没了 因为服务器一重启 你服务信息都丢了 所以得存在磁盘上 文件算磁盘 所以持久层包括文件
        //             存在文件里有一个坏处 就是你这个数据的格式不统一 我可以按照一种格式存 别人也可以按照一个格式存 这样我们在阅读数据的时候非常变扭
        //             非常难以理解 所以采用一种通用的存储的结构 通用的数据格式 所以一般会采用数据库 MySQL Oracle是关系型数据库
        //             MongoDB Redis 非关系型的
        //
        //
        //     每层的命名
        //     Web层: LoginController(接收参数, 判断是否非法, 传给服务层)
        //     服务层: LoginService(获取这个用户的密码, 进行比较)
        //     DOA层: LoginDAO(从数据库获取数据, 并转换为对象) 
        //     持久层(不需要存在): 不需要我们去命名 持久层是文件或者数据去代替这个角色 不是我们来操作的 所以我们不要给持久层创建一个层 
        //                 只是持久层是一个概念 是由文件或数据库来顶替的
        //     Domain: User  数据转换为对象 对象在这存储
            
        //     Web负责接收这个请求 DOA层去查询数据 查询完数据之后给他转换为User对象 服务层来判断这个User对象和传过来的User对象来比较 密码是否一致 如果一致就告诉前端一致
        //         给他返回下一个页面 如果不一致告诉前端要提示错误
            
        //     不同的层在NodeJs是怎么体现的 不同的层其实是不同的文件夹   
        //     web 
        //     service
        //     dao
        //     domain(实例对象 学生老师用户..) 
        //     util(比如对时间这个方法有一定的要求 封装一些特殊的参数 写一些小工具)
        //     分层是为了每一层的逻辑更加清晰 设计模式: 符合单一职责原则  让每一层的逻辑统一 足够简单
        //
        //
        // 2. 模块化
        //   (1) ES6导入和导出 
        //      模块化怎么体现   先引入boostrap(作为基础模块 达到最少引用的效果) 再引入弹层 表格     引入顺序要确定
        //   (2) Es3丶5缺点：缺少模块化的概念 
        //     
        //  JS规范缺乏管理机制 boostrap和jQuery版本混乱
        //  yum install wget   Linux命令  中央仓库有规定的域名 全世界所有的Linux计算机全都会连接它 软件商上传中央仓库 我们直接访问中央仓库就行
        //       NodeJs有这个机制 NPM为啥NPM install Node有个NPM中央仓库 机器需要下载说明东西 只需Npm install 也是访问中央仓库 
        //       在中央仓库把这个数拉下来 这个是Node的特点 用node去下载东西和安装东西非常方便
        // 服务器： Linux 必须依赖中央仓库 
        



    
    
    
    </script>

</body>
</html>